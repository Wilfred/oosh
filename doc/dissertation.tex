% Copyright 2009 Wilfred Hughes, CC-BY license
\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable
\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Wilfred Hughes}

\vspace*{60mm}
\begin{center}
\Huge
{\bf oosh: An object oriented shell} \\
\vspace*{5mm}
Computer Science Part II \\
\vspace*{5mm}
Churchill College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Wilfred Hughes                       \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf oosh: An object oriented shell \\
Examination:        & \bf Computer Science Part II, 2009-2010        \\
Word Count:         & \bf 1587\footnotemark[1] \\
Project Originator: & \bf Wilfred Hughes                    \\
Supervisor:         & \bf David Eyers                    \\ 
\end{tabular}
}

\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

\section*{Work Completed}

\section*{Special Difficulties}
 
\newpage
\section*{Declaration}

I, Wilfred Hughes of Churchill College, being a candidate for Part II
of the Computer Science Tripos, hereby declare that this dissertation
and the work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

% previous projects in this area:
% G Beasley 2003
% J Harbin 2005
% J Tippell 2006 -- Josh (no true pipelines)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}

% overview
% why this solution?

\section{Overview}
Watch this space.


\cleardoublepage

\chapter{Preparation}

\section{Historical Motivations}
The command line shell (henceforth \emph{shell}) is one of the earliest user
interfaces in the history of computing, with recognisable shells having appeared
by 1965 \cite{multics}on the Multics system. A shell offers the user a
convenient abstraction to interact with his system. He may perform common tasks
using considerably shorter commands than using his programming language of
choice. A shell scripting language, therefore, has always been an exchange of
power for brevity.

The original Bourne shell was a product of hacking and experimentation, so was
never formally specified. Bash has pursued backwards compatibility.

Today's shells are therefore optimised for common use cases that are
outdated. They have ill-specified languages, making it hard for the user to
exercise confidence in preparing scripts---indeed, even implementing
\texttt{sh}-compatible behaviour is non-trivial.

I revisited these assumptions. \texttt{who | wc} is not supported by the
original grammar, and pipes are an early (but not an original) feature. How can
I make these commands simpler? What other use cases have emerged since the
original shell formulation?

\section{Existing Solutions}
% feature matrix/table?
I evaluated several well-known shells available today. One of the most popular
options is Bash, which is the default on GNU/Linux and Mac OS X.

A more recent alternative to Bash is Fish, the Friendly Interactive Shell. Fish
is not a substantial departure from Bash, but breaks backwards compatibility to
simplify the scripting language it accepts.

Another recent development is PowerShell, a Microsoft scripting language and
shell released in 2006. PowerShell is a more radical departure from traditional
shell design, offering an object-oriented approach. Whilst this offers an
increase in expressive power, the PowerShell design does not seek to optimise
the interface for interactive usage. PowerShell cmdlets use a more verbose
noun-verb naming scheme and the programmer is sometimes exposed to underlying
Windows API for simple networking tasks.

\section{Requirements}
I needed to create a shell that would be familiar to an experience shell
user, so my shell should follow shell conventions where sensible. This shell
would enable the user to transfer structured data through pipelines using
familiar pipeline tools. It would also enable convenient network access and
optimise network data flow where possible.

In addition to the shell with its built-ins, I needed a selection of programs
that understood the structured data and demonstrated its flexibility and
versatility. Clearly with data in a tabular format, a set of commands that offer
database-like commands would be both familiar to the user and powerful. Another
clear advantage of structured data is the ability to draw graphs, so an
automatic graphing facility was created.

% needs more on optimisation

\section{Development Approach}
Since my design aimed to build on traditional shell design, extending an
existing shell was an option worth considering, particularly since most Unix
shells are available under an open-source lincense. I investigated building on
top of Bash or Fish, but both of these were substantially 

% features:
% n/w optimisation
% new pipeline metaphor -- save, y-pipe, networking
% strict data format
% interleave new commands
% primitive namespacing
% familiar syntax

% bash and fish: no proper grammar. hard to change guts for more radical
% features, bash substantial body of code -- compatibilty unwanted, no hackable grammar
% python offered cmd.py which is skeleton shell
% networking easier in python, text manipulation particularly so

From scratch. Git. Github. Python. Fairly exploratory. Fish-inspired
grammar. Simplified system as proof of concept.

Typical CLI commands are developed iteratively, which is why commands print
their usage guidelines if used incorrectly. Pipeline saving allows the user to
develop his pipelines more incrementally.

A shell is not as expressive as a programming language (sh was unusual in having
optional ; in its day), and a REPL has a different feel. A shell optimises for
few keystrokes for commands, simple system adminstration tasks, and so on. A
shell has no floating point maths and limited integer support. Almost everything
is exported to invoked processes to handle instead.

% investigation -- compared to existing systems
%   -- bash, fish, powershell, osh (Timoth Budd 1989), REPLs, cmd.exe
%     -- macro language vs programming language
%   -- bash particularly: lex and parse approach, backwards compat
% requirements (from proposal)
% development approach -- development environment, VCS, backup
%   -- system design -- diagrams of structure!
%   -- different implementation approaches considered
%     -- modify existing work, start from scratch
%     -- similar grammar, readily piped to system below?
% theory?
% summary

% quote: The grammar presented in Bourne's paper describing the shell
% distributed with the Seventh Edition of Unix is so far off that it does not
% allow the command who|wc. In fact, as Tom Duff states:

% “Nobody really knows what the Bourne shell's grammar is. Even examination of
% the source code is little help.” -- Tom Duff, “Rc-A Shell for Plan 9 and UNIX
% systems”, Proc. of the Summer 1990 EUUG Conf., London, July, 1990, pp. 21-33

% The POSIX.2 standard includes a yacc grammar that comes close to capturing the
% Bourne shell's behavior, but it disallows some constructs which sh accepts
% without complaint-and there are scripts out there that use them.

\cleardoublepage

\chapter{Implementation}

% architecture
%   -- snazzy pictures!
% what does it do? how? why that way? what inputs? what outputs?

\cleardoublepage

\chapter{Evaluation}

% what was evaluated?
% what were the results?
%   -- no of processes spawned
%   -- length of equivalent bash shells (can use old commands still!)
%   -- network data comparisons (fixed and variable cost increases measured)
%   -- performance
%     -- wall clock time
%     -- memory and CPU usage
% testing/debugging
% comparing against requirements

\cleardoublepage
\chapter{Conclusion}

% aims again
% accomplishments -- likes, dislikes, results
% hindsight thoughts -- better approaches
% future prospects

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\begin{thebibliography}{1} % at most one citation

\bibitem{multics}
  Louis Pouzin
  \emph{Multics: The Origin of the Shell}
  http://www.multicians.org/shell.html

\end{thebibliography}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{References}

\chapter{Project Proposal}
% assumes we are compiling the dissertation using makepdf.sh
% use same formatting as proposal had in header
\parindent 0pt
\parskip 6pt
\include{proposal_include}

\end{document}
