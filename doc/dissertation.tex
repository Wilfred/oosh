% Copyright 2009 Wilfred Hughes, CC-BY license
\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}

% for pretty printing grammar in BNF
\usepackage{bnf}

\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex

\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable
\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Wilfred Hughes}

\vspace*{60mm}
\begin{center}
\Huge
{\bf oosh: An object oriented shell} \\
\vspace*{5mm}
Computer Science Part II \\
\vspace*{5mm}
Churchill College \\
\vspace*{5mm}
\today  % today's date
\end{center}

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Wilfred Hughes                       \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf oosh: An object oriented shell \\
Examination:        & \bf Computer Science Part II, 2009-2010        \\
Word Count:         & \bf 1587\footnotemark[1] \\
Project Originator: & \bf Wilfred Hughes                    \\
Supervisor:         & \bf David Eyers                    \\ 
\end{tabular}
}

\footnotetext[1]{This word count was computed
by {\tt detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

\section*{Work Completed}

\section*{Special Difficulties}
 
\newpage
\section*{Declaration}

I, Wilfred Hughes of Churchill College, being a candidate for Part II
of the Computer Science Tripos, hereby declare that this dissertation
and the work described in it are my own work, unaided except as may be
specified below, and that the dissertation does not contain material
that has already been used to any substantial extent for a comparable
purpose.

\bigskip
\leftline{Signed}

\medskip
\leftline{Date}

\cleardoublepage

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

% previous projects in this area:
% G Beasley 2003
% J Harbin 2005
% J Tippell 2006 -- Josh (no true pipelines)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
% need to decide on capitalisation conventions for oosh, bash and fish
My project was to create a Unix shell from scratch. This gave me the opportunity
to re-evaluate design decisions made by previous shell developers. I therefore
explored a design that made today's common shell tasks easier.

% overview
% why this solution?

\section{Overview}
Watch this space.


\cleardoublepage

\chapter{Preparation}

\section{Historical Motivations}
The command line shell (henceforth \emph{shell}) is one of the earliest user
interfaces in the history of computing, with recognisable shells having appeared
by 1965 \cite{multics}on the Multics system. A shell offers the user a
convenient abstraction to interact with his system. He may perform common tasks
using considerably shorter commands than using his programming language of
choice. A shell scripting language, therefore, has always been an exchange of
power for brevity.

The original Bourne shell was a product of hacking and experimentation, so was
never formally specified. Bash has pursued backwards compatibility.

Today's shells are therefore optimised for common use cases that are
outdated. They have ill-specified languages, making it hard for the user to
exercise confidence in preparing scripts---indeed, even implementing
\texttt{sh}-compatible behaviour is non-trivial.

I revisited these assumptions. \texttt{who | wc} is not supported by the
original grammar, and pipes are an early (but not an original) feature. How can
I make these commands simpler? What other use cases have emerged since the
original shell formulation?

\section{Existing Solutions}
% feature matrix/table?
I evaluated several well-known shells available today. One of the most popular
options is Bash, which is the default on GNU/Linux and Mac OS X.

A more recent alternative to Bash is Fish, the Friendly Interactive Shell. Fish
is not a substantial departure from Bash, but breaks backwards compatibility to
simplify the scripting language it accepts.

Another recent development is PowerShell, a Microsoft scripting language and
shell released in 2006. PowerShell is a more radical departure from traditional
shell design, offering an object-oriented approach. Whilst this offers an
increase in expressive power, the PowerShell design does not seek to optimise
the interface for interactive usage. PowerShell cmdlets use a more verbose
noun-verb naming scheme and the programmer is sometimes exposed to underlying
Windows API for simple networking tasks.

\section{Requirements}
I needed to create a shell that would be familiar to an experience shell
user, so my shell should follow shell conventions where sensible. This shell
would enable the user to transfer structured data through pipelines using
familiar pipeline tools. It would also enable convenient network access and
optimise network data flow where possible.

In addition to the shell with its built-ins, I needed a selection of programs
that understood the structured data and demonstrated its flexibility and
versatility. Clearly with data in a tabular format, a set of commands that offer
database-like commands would be both familiar to the user and powerful. Another
clear advantage of structured data is the ability to draw graphs, so an
automatic graphing facility was created.

% needs more on optimisation

\section{Development Approach}
Since my design aimed to build on traditional shell design, extending an
existing shell was an option worth considering, particularly since most Unix
shells are available under an open-source lincense. I investigated building on
top of Bash or Fish, but both of these were substantial pieces of C code, most
of which would require major changes to work with my intended features. I
concluded that starting afresh was my best option.

Since I was developing a tools for a modern Unix system, I chose a workflow that
followed today's Unix coding practices. I chose to write my shell in Python, a
modern scripting language, used Emacs as my editor and used Git, a distributed
version control system to track changes. By the same logic I chose to host my
code on GitHub, which had the additional benefit of acting as an off-site
backup. Later on I needed a parser and lexer so chose Python implementations of
Lex and Yacc as these are also standard tools.

My initial specification was very broad, which enabled me to use a fairly
exploratory style of coding. My final grammar is in figure {\em foo} and was
developed iteratively after researching the syntax used in bash and fish.

Ultimately a mainstream shell is a very large body of code (for example, Bash
4.1 contains over 140,000 lines of code) and so I could not hope to replicate all
this functionality in the time available. My objective then became to produce a
proof-of-concept shell that demonstrated the advantages of my design.
% in bash directory ran $ find . -name '*.[ch]' | xargs wc -l


% features:
% n/w optimisation
% new pipeline metaphor -- save, y-pipe, networking
% strict data format
% interleave new commands
% primitive namespacing
% familiar syntax

% bash and fish: no proper grammar. hard to change guts for more radical
% features, bash substantial body of code -- compatibilty unwanted, no hackable grammar
% python offered cmd.py which is skeleton shell
% networking easier in python, text manipulation particularly so

From scratch. Git. Github. Python. Fairly exploratory. Fish-inspired
grammar. Simplified system as proof of concept.

Typical CLI commands are developed iteratively, which is why commands print
their usage guidelines if used incorrectly. Pipeline saving allows the user to
develop his pipelines more incrementally.

A shell is not as expressive as a programming language (sh was unusual in having
optional ; in its day), and a REPL has a different feel. A shell optimises for
few keystrokes for commands, simple system adminstration tasks, and so on. A
shell has no floating point maths and limited integer support. Almost everything
is exported to invoked processes to handle instead.

% investigation -- compared to existing systems
%   -- bash, fish, powershell, osh (Timoth Budd 1989), REPLs, cmd.exe
%     -- macro language vs programming language
%   -- bash particularly: lex and parse approach, backwards compat
% requirements (from proposal)
% development approach -- development environment, VCS, backup
%   -- system design -- diagrams of structure!
%   -- different implementation approaches considered
%     -- modify existing work, start from scratch
%     -- similar grammar, readily piped to system below?
% theory?
% summary

% quote: The grammar presented in Bourne's paper describing the shell
% distributed with the Seventh Edition of Unix is so far off that it does not
% allow the command who|wc. In fact, as Tom Duff states:

% “Nobody really knows what the Bourne shell's grammar is. Even examination of
% the source code is little help.” -- Tom Duff, “Rc-A Shell for Plan 9 and UNIX
% systems”, Proc. of the Summer 1990 EUUG Conf., London, July, 1990, pp. 21-33

% The POSIX.2 standard includes a yacc grammar that comes close to capturing the
% Bourne shell's behavior, but it disallows some constructs which sh accepts
% without complaint-and there are scripts out there that use them.

\cleardoublepage

\chapter{Implementation}
The final result of my project was the shell client itself, a simple server and
a selection of commands that understood the oosh data structures. I also wrote
some simple scripts to demonstrate the power and flexibility of my design.

(diagram of file layout)

\section{Data Structures}
My initial design was to have structured data pass through pipes between the
commands, but this still left me with a variety of implementation
possibilities. The data I wanted to manipulate turned out to fit a tabular
format well, so my iterations focused on a representation of each line of data
with labels. %unclear, clarify
One of the initial ideas was to use an object oriented programming approach, so
my first prototype % tracer code analogy from the pragmatic programmer?
used an object which encapsulated this. However successive refactorings reduced
this object to the point I was able to replace it entirely with Python {\tt
  dict}s (the mapping structure primitive in Python).

(example of some raw data)

(example of same data pretty-printed)

\section{Syntax}
When I developed the first parts of Oosh I did not specify a grammar and simply
modified the syntax as I went along. When I implemented a full interpreter I
formalised the syntax I had developed. This approach enabled me to experiment
without having to radically restructure the code at each iteration.

\subsection{Grammar}
\begin{grammar}
      [(colon){$::=$}]
      [(semicolon){$|\,$}]
      [(nonterminal){$\langle$}{$\rangle$}]
      [(quote){}{}] % grim hack since ; has meaning so we use ";"
<commands> : <commands>";" <commands>\\
;commands NAMEDPIPE
;<while>
;<if>
;<assign>
;<for>
;<command>
;$\epsilon$

<for> : for STRING in <values>";" do <commands>";" end

<while> : while <command>";" do <commands>";" end

<if> : if <command>";" do <commands>";" end\\
;if <command>";" do <commands>";" else do <commands>";" end

<assign> : set STRING <value>

<command> : <simplecommand>\\
;NAMEDPIPE <simplecommand>\\
;MULTIPIPE <multicommand> PIPE <simplecommand>\\
;MULTIPIPE <multicommand>

<values> : <value> <values>
;<value>

<value> : STRING
;VARIABLE
;QUOTEDSTRING

<simplecommand> : <values>
;PIPE <simplecommand>
    
<multicommand> : <values>
\end{grammar}

\section{The Shell}
The Oosh client is the largest piece of code % waffle
and can function without a server. Basic command line interaction is provided by
the {\tt cmd.Cmd} object in the standard Python library, so from the second
commit to the codebase I had standalone code. % don't be chronological!

Once the input has been lexed and parsed, the client recurses on the parse tree
% (simplified) picture of parse tree needed
and evalutes it. Within each pipeline % have pipelines been explained by this point?
a {\tt PipePointer} is passed along to abstract away the actual location of the
data. This enables the shell to use Unix pipes locally % would be good to benchmark this
but still move data across the network as needed.

\section{Networking}
% need intro para

The server is a very simple design, only permitting one user to interact at any
one point. Using the client, the user specifies the location where he wishes
commands to be run. Once the user has logged in to a remote server, the client
will automatically initiate commands on the server. Since the client collects
data on the users behalf we can send the data lazily.

\section{Command Selection}

\section{Example Scripts}
% architecture
%   -- snazzy pictures!
% what does it do? how? why that way? what inputs? what outputs?


% problems overcome:
% 1. python documentation bugs (in regex IIRC)
% 2. python 2 library compatibility
% 3. Escape codes (can't print for debugging!)
% 4. limits of shell output (used for cross product tests)


\cleardoublepage

\chapter{Evaluation}

% what was evaluated?
% what were the results?
%   -- no of processes spawned
%   -- length of equivalent bash shells (can use old commands still!)
%   -- network data comparisons (fixed and variable cost increases measured)
%   -- performance
%     -- wall clock time
%     -- memory and CPU usage
% testing/debugging
% comparing against requirements

\cleardoublepage
\chapter{Conclusion}

% aims again
% accomplishments -- likes, dislikes, results
% hindsight thoughts -- better approaches
% future prospects

\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography

\addcontentsline{toc}{chapter}{Bibliography}
\begin{thebibliography}{1} % at most one citation

\bibitem{multics}
  Louis Pouzin
  \emph{Multics: The Origin of the Shell}
  http://www.multicians.org/shell.html

\end{thebibliography}
\cleardoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{References}

\chapter{Project Proposal}
% assumes we are compiling the dissertation using makepdf.sh
% use same formatting as proposal had in header
\parindent 0pt
\parskip 6pt
\include{proposal_include}

\end{document}
