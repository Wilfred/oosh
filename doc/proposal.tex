% Copyright 2009 Wilfred Hughes, CC-BY license
\documentclass[12pt]{article}
\usepackage{a4wide} % increase page width

\parindent 0pt
\parskip 6pt

\begin{document}

\thispagestyle{empty}

\rightline{\large Wilfred Hughes}
\medskip
\rightline{\large Churchill}
\medskip
\rightline{\large wrah2}

\vfil

\centerline{\large Part II Computer Science Project Proposal}
\vspace{0.4in}
\centerline{\Large\bf oosh: An object oriented shell}
\vspace{0.3in}
\centerline{\large \today}

\vfil

{\bf Project Originator:} Wilfred Hughes

\vspace{0.1in}

{\bf Resources Required:} See attached Project Resource Form

\vspace{0.5in}

{\bf Project Supervisor:} David Eyers

\vspace{0.2in}

{\bf Signature:}

\vspace{0.5in}

{\bf Director of Studies:}  John Fawcett

\vspace{0.2in}

{\bf Signature:}

\vspace{0.5in}

{\bf Overseers:} Jon Crowcroft and Pietro Lio

\vspace{0.2in}

{\bf Signatures:}

\vfil
\eject

\section*{Introduction and Description of the Work}
Unix shells offer powerful ways of working with data and files using a
command line interface. Traditionally they were only a simplified interface
to the kernel, passing unstructured text streams between programs.

I intend to extend this idea to an `object stream' where the data
passed between programs contains semantic structure and metadata. This
will enable powerful data manipulation and processing that is not
possible with a traditional shell.

Due to the age of the Unix shell design (with many design decisions
unchanged from the original Unix shell circa 1971 \cite{firstshell}),
the design is simple since the computer systems it first ran on
offered limited power. A traditional shell always copies data to the
next program in the pipe. This also requires remote data locations to
be mounted before the data could be used.

My design will modify the basic shell design so that programs are
presented with file pointers that point to local or remote files. A
user may therefore write a simple script that accesses a file in a
compressed archive stored remotely. A traditional shell would require
him to learn a heterogeneous collection of commands that connect to
different protocols or decompress different file types.

\section*{Resources Required}
I plan to perform most of my work using my personal computer. The code
will be stored in a remote git repository so I need an Internet
connection to push my changes there regularly. If necessary I can move
to any Internet connected Unix system that offers a Python interpreter.

\section*{Starting Point}
My personal computer has run Linux for some time so I have some
expertise with Unix systems and shells. I also attended the Unix tools
lectures given by Dr Marcus Kuhn during part IB. My Python experience
is simply some toy programs I have written in the past. Finally, I
have learnt Emacs over the summer vacation.

\section*{Substance and Structure of the Project}
The project will be written in Python due to it being a mature
interpreted language that supports object oriented programming. I
intend to fully exploit the wider Python ecosystem, using the tools
available to perform tasks such as parser building and test framework
development.

The shell itself will offer a full interpreter for shell scripts,
using a syntax similar to that found in bash \cite{bash}. POSIX
compliance \cite{posix} is not necessary for this project, and other
research projects in this area have not aimed for compliance to improve
readability \cite{fish} or power \cite{powershell}. I will therefore
extend the bash syntax to make shell scripts more expressive. 

Many Unix utilities output data in columns, largely for readability. I
intend to make this convention a requirement, so that data is always
structured in a tabular format. This will enable me to generalise the
idea of utilities such as \texttt{grep} to offer the user more powerful data
manipulation facilities. I will implement a set of programs that make
the full expressiveness of the relational algebra available.

With the addition of metadata to what was previously unstructured text
data I can develop applications that are content-aware; capable of
modifying their behaviour based on data format. Semantic information
available also enables the development of tools that understand the
data that flows through them. This will enable the creation of tools
that visualise the data in a natural way.

To demonstrate the additional power due to manipulating structured
data, I will also develop a selection of tools that provide
interesting data to analyse through the oosh facilities. Obvious
sources of interesting data include the filesystem, logs, system
maintenance tools and network testing tools. This will enable the user
to easily build scripts that analyse (for example) disk space
consumption over time broken down by permissions and file type,
application logging for high CPU applications with visualisations or
nearby router performance versus facilities offered by the router.

\section*{Success Criteria}
The final outcome of the project should provide:

\begin{enumerate}
\item A oosh shell syntax interpreter
\item Some example scripts, including:
  \begin{itemize}
  \item drawing a chart that shows disk space consumption separated by
    permissions and file type
  \item drawing a graph of hop-by-hop router latency relative to the
    local host
  \item monitoring CPU usage for different users or groups
  \item fetching and compiling source code from remote servers
  \end{itemize}
\item Network transparent file access to programs run within oosh,
  including FTP and HTTP support
\item Programs which exploit the fact that the object stream
  contains semantic information, including relational algebra
  functionality and automatic graph generation
\item A collection of benchmarks which show the speed difference
  between oosh and other shells
\item A clearly structured dissertation
\end{enumerate}

\section*{Timetable and Milestones}

% this end date pushed back slightly due to language change
\subsection*{Weeks 1 and 2 (8/10/2009 to 24/10/2009)}
Write the project proposal. Set up code repository on public facing
server. Write skeleton code and test code repository. Design and
implement object stream structure. Set up a test harness to facilitate
unit testing. Research Python console libraries.

Milestones: Proposal written and submitted. Some basic code available
in git repository.

\subsection*{Weeks 3 and 4 (25/10/2009 to 4/11/2009)}
Research most used Unix command line tools. Select a collection to
implement, plus some others which demonstrate the power of object
streams. Implement them.

Milestones: Several commands available to be run within oosh.

\subsection*{Weeks 5 and 6 (5/11/2009 to 18/11/2009)}
Research Python networking facilities and develop network independence
features. Add command line tools which demonstrate its
usefulness. Start benchmarking to measure networking overhead and
tolerance to network losses.

Milestones: Commands available within oosh that use the networking
facilities. Some raw benchmark data collected.

\subsection*{Weeks 7 and 8 (19/11/2009 to 2/12/2009)}
Finalise oosh syntax for shell scripting. Implement
interpreter. Research most common bash shell scripts. Create
demonstration oosh shell scripts.

Milestones: Formal specification of oosh shell syntax. Example scripts
written and working.

{\bf End of Michaelmas term}.

\subsection*{Weeks 9 to 11 (3/12/2009 to 23/12/2009)}
Slack time. Extend test coverage. Add UI polish. Implement data
visualisation facilities.

Milestones: Higher test coverage. Shell tab completion. Oosh reaches
feature completion.

{\bf Beginning of Lent term}.

\subsection*{Week 12 (14/1/2010 to 20/1/2010)}
Write progress report. Prepare demonstration. Review timetable.

Milestones: Written and submitted progress report. Prepared and given
demonstration. Finalised timetable available.

\subsection*{Weeks 13 to 15 (21/1/2010 to 10/2/2010)}
Write main body dissertation including preparation and
implementation. Write text, draw figures, prepare bibliography.

Milestones: Main body of dissertation written.

\subsection*{Weeks 16 to 18 (11/2/2010 to 3/3/2010)}
Write evaluation section of dissertation. Perform any remaining
benchmarks as necessary.

Milestones: Text of dissertation complete and proof read by at
least supervisor and director of studies.

\subsection*{Week 19 (4/3/2010 to 10/3/2010)}
Solicit dissertation feedback. Exchange dissertations with other
students and proof read. Print dissertation.

Milestones: Paper copy of final dissertation draft.

{\bf End of Lent term}.

{\bf Dissertation and source code due on the 14 May 2010}.


\begin{thebibliography}{9} % at most 9 citations

\bibitem{firstshell}
  Dennis M. Ritchie,
  \emph{The Evolution of the Unix Time-sharing System}.
  http://cm.bell-labs.com/cm/cs/who/dmr/hist.html fetched 15th October
  2009.

\bibitem{bash}
  The GNU Project,
  \emph{Bash Reference Manual}.
  http://www.gnu.org/software/bash/manual/bashref.html fetched 15th
  October 2009.
 
\bibitem{posix}
  The Open Group,
  \emph{POSIX:2008 (IEEE Std 1003.1-2008) Shell and Utilities}.
  http://www.opengroup.org/onlinepubs/9699919799/ fetched 15th October
  2009.

\bibitem{fish}
  Axel Liljencrantz,
  \emph{Fish user documentation}.
  http://fishshell.org/user\_doc/index.html fetched 15th October 2009.

\bibitem{powershell}
  Microsoft Developer Network,
  \emph{Windows Powershell Quickstart}.
  http://channel9.msdn.com/wiki/windowspowershellquickstart/ fetched
  15th October 2009.

\end{thebibliography}

\end{document}
